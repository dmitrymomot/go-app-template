/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/alpinejs@3.13.5/dist/module.cjs.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJS = (e, t) => function () { return t || (0, e[__getOwnPropNames(e)[0]])((t = { exports: {} }).exports, t), t.exports }, __export = (e, t) => { for (var n in t) __defProp(e, n, { get: t[n], enumerable: !0 }) }, __copyProps = (e, t, n, r) => { if (t && "object" == typeof t || "function" == typeof t) for (let i of __getOwnPropNames(t)) __hasOwnProp.call(e, i) || i === n || __defProp(e, i, { get: () => t[i], enumerable: !(r = __getOwnPropDesc(t, i)) || r.enumerable }); return e }, __toESM = (e, t, n) => (n = null != e ? __create(__getProtoOf(e)) : {}, __copyProps(!t && e && e.__esModule ? n : __defProp(n, "default", { value: e, enumerable: !0 }), e)), __toCommonJS = e => __copyProps(__defProp({}, "__esModule", { value: !0 }), e), require_shared_cjs = __commonJS({ "node_modules/@vue/shared/dist/shared.cjs.js"(e) { "use strict"; function t(e, t) { const n = Object.create(null), r = e.split(","); for (let e = 0; e < r.length; e++)n[r[e]] = !0; return t ? e => !!n[e.toLowerCase()] : e => !!n[e] } Object.defineProperty(e, "__esModule", { value: !0 }); var n = { 1: "TEXT", 2: "CLASS", 4: "STYLE", 8: "PROPS", 16: "FULL_PROPS", 32: "HYDRATE_EVENTS", 64: "STABLE_FRAGMENT", 128: "KEYED_FRAGMENT", 256: "UNKEYED_FRAGMENT", 512: "NEED_PATCH", 1024: "DYNAMIC_SLOTS", 2048: "DEV_ROOT_FRAGMENT", [-1]: "HOISTED", [-2]: "BAIL" }, r = { 1: "STABLE", 2: "DYNAMIC", 3: "FORWARDED" }, i = t("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt"); var o = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", a = t(o), s = t(o + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"), l = /[>/="'\u0009\u000a\u000c\u0020]/, c = {}; var u = t("animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width"), d = t("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"); var f = /;(?![^(]*\))/g, p = /:(.+)/; function _(e) { const t = {}; return e.split(f).forEach((e => { if (e) { const n = e.split(p); n.length > 1 && (t[n[0].trim()] = n[1].trim()) } })), t } var g = t("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"), h = t("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"), m = t("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"), v = /["'&<>]/; var b = /^-?>|<!--|-->|--!>|<!-$/g; function y(e, t) { if (e === t) return !0; let n = M(e), r = M(t); if (n || r) return !(!n || !r) && e.getTime() === t.getTime(); if (n = C(e), r = C(t), n || r) return !(!n || !r) && function (e, t) { if (e.length !== t.length) return !1; let n = !0; for (let r = 0; n && r < e.length; r++)n = y(e[r], t[r]); return n }(e, t); if (n = N(e), r = N(t), n || r) { if (!n || !r) return !1; if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) { const r = e.hasOwnProperty(n), i = t.hasOwnProperty(n); if (r && !i || !r && i || !y(e[n], t[n])) return !1 } } return String(e) === String(t) } var x, w = (e, t) => T(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce(((e, [t, n]) => (e[`${t} =>`] = n, e)), {}) } : P(t) ? { [`Set(${t.size})`]: [...t.values()] } : !N(t) || C(t) || I(t) ? t : String(t), S = Object.freeze({}), A = Object.freeze([]), E = /^on[^a-z]/, k = Object.assign, O = Object.prototype.hasOwnProperty, C = Array.isArray, T = e => "[object Map]" === F(e), P = e => "[object Set]" === F(e), M = e => e instanceof Date, j = e => "function" == typeof e, R = e => "string" == typeof e, N = e => null !== e && "object" == typeof e, D = Object.prototype.toString, F = e => D.call(e), I = e => "[object Object]" === F(e), L = t(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), $ = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, B = /-(\w)/g, q = $((e => e.replace(B, ((e, t) => t ? t.toUpperCase() : "")))), H = /\B([A-Z])/g, z = $((e => e.replace(H, "-$1").toLowerCase())), V = $((e => e.charAt(0).toUpperCase() + e.slice(1))), U = $((e => e ? `on${V(e)}` : "")); e.EMPTY_ARR = A, e.EMPTY_OBJ = S, e.NO = () => !1, e.NOOP = () => { }, e.PatchFlagNames = n, e.babelParserDefaultPlugins = ["bigInt", "optionalChaining", "nullishCoalescingOperator"], e.camelize = q, e.capitalize = V, e.def = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }) }, e.escapeHtml = function (e) { const t = "" + e, n = v.exec(t); if (!n) return t; let r, i, o = "", a = 0; for (i = n.index; i < t.length; i++) { switch (t.charCodeAt(i)) { case 34: r = "&quot;"; break; case 38: r = "&amp;"; break; case 39: r = "&#39;"; break; case 60: r = "&lt;"; break; case 62: r = "&gt;"; break; default: continue }a !== i && (o += t.substring(a, i)), a = i + 1, o += r } return a !== i ? o + t.substring(a, i) : o }, e.escapeHtmlComment = function (e) { return e.replace(b, "") }, e.extend = k, e.generateCodeFrame = function (e, t = 0, n = e.length) { let r = e.split(/(\r?\n)/); const i = r.filter(((e, t) => t % 2 == 1)); r = r.filter(((e, t) => t % 2 == 0)); let o = 0; const a = []; for (let e = 0; e < r.length; e++)if (o += r[e].length + (i[e] && i[e].length || 0), o >= t) { for (let s = e - 2; s <= e + 2 || n > o; s++) { if (s < 0 || s >= r.length) continue; const l = s + 1; a.push(`${l}${" ".repeat(Math.max(3 - String(l).length, 0))}|  ${r[s]}`); const c = r[s].length, u = i[s] && i[s].length || 0; if (s === e) { const e = t - (o - (c + u)), r = Math.max(1, n > o ? c - e : n - t); a.push("   |  " + " ".repeat(e) + "^".repeat(r)) } else if (s > e) { if (n > o) { const e = Math.max(Math.min(n - o, c), 1); a.push("   |  " + "^".repeat(e)) } o += c + u } } break } return a.join("\n") }, e.getGlobalThis = () => x || (x = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {}), e.hasChanged = (e, t) => e !== t && (e == e || t == t), e.hasOwn = (e, t) => O.call(e, t), e.hyphenate = z, e.invokeArrayFns = (e, t) => { for (let n = 0; n < e.length; n++)e[n](t) }, e.isArray = C, e.isBooleanAttr = s, e.isDate = M, e.isFunction = j, e.isGloballyWhitelisted = i, e.isHTMLTag = g, e.isIntegerKey = e => R(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e, e.isKnownAttr = d, e.isMap = T, e.isModelListener = e => e.startsWith("onUpdate:"), e.isNoUnitNumericStyleProp = u, e.isObject = N, e.isOn = e => E.test(e), e.isPlainObject = I, e.isPromise = e => N(e) && j(e.then) && j(e.catch), e.isReservedProp = L, e.isSSRSafeAttrName = function (e) { if (c.hasOwnProperty(e)) return c[e]; const t = l.test(e); return t && console.error(`unsafe attribute name: ${e}`), c[e] = !t }, e.isSVGTag = h, e.isSet = P, e.isSpecialBooleanAttr = a, e.isString = R, e.isSymbol = e => "symbol" == typeof e, e.isVoidTag = m, e.looseEqual = y, e.looseIndexOf = function (e, t) { return e.findIndex((e => y(e, t))) }, e.makeMap = t, e.normalizeClass = function e(t) { let n = ""; if (R(t)) n = t; else if (C(t)) for (let r = 0; r < t.length; r++) { const i = e(t[r]); i && (n += i + " ") } else if (N(t)) for (const e in t) t[e] && (n += e + " "); return n.trim() }, e.normalizeStyle = function e(t) { if (C(t)) { const n = {}; for (let r = 0; r < t.length; r++) { const i = t[r], o = e(R(i) ? _(i) : i); if (o) for (const e in o) n[e] = o[e] } return n } if (N(t)) return t }, e.objectToString = D, e.parseStringStyle = _, e.propsToAttrMap = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, e.remove = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, e.slotFlagsText = r, e.stringifyStyle = function (e) { let t = ""; if (!e) return t; for (const n in e) { const r = e[n], i = n.startsWith("--") ? n : z(n); (R(r) || "number" == typeof r && u(i)) && (t += `${i}:${r};`) } return t }, e.toDisplayString = e => null == e ? "" : N(e) ? JSON.stringify(e, w, 2) : String(e), e.toHandlerKey = U, e.toNumber = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, e.toRawType = e => F(e).slice(8, -1), e.toTypeString = F } }), require_shared = __commonJS({ "node_modules/@vue/shared/index.js"(e, t) { "use strict"; t.exports = require_shared_cjs() } }), require_reactivity_cjs = __commonJS({ "node_modules/@vue/reactivity/dist/reactivity.cjs.js"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var t, n = require_shared(), r = new WeakMap, i = [], o = Symbol("iterate"), a = Symbol("Map key iterate"); function s(e, r = n.EMPTY_OBJ) { (function (e) { return e && !0 === e._isEffect })(e) && (e = e.raw); const o = function (e, n) { const r = function () { if (!r.active) return e(); if (!i.includes(r)) { c(r); try { return p(), i.push(r), t = r, e() } finally { i.pop(), _(), t = i[i.length - 1] } } }; return r.id = l++, r.allowRecurse = !!n.allowRecurse, r._isEffect = !0, r.active = !0, r.raw = e, r.deps = [], r.options = n, r }(e, r); return r.lazy || o(), o } var l = 0; function c(e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } } var u = !0, d = []; function f() { d.push(u), u = !1 } function p() { d.push(u), u = !0 } function _() { const e = d.pop(); u = void 0 === e || e } function g(e, n, i) { if (!u || void 0 === t) return; let o = r.get(e); o || r.set(e, o = new Map); let a = o.get(i); a || o.set(i, a = new Set), a.has(t) || (a.add(t), t.deps.push(a), t.options.onTrack && t.options.onTrack({ effect: t, target: e, type: n, key: i })) } function h(e, i, s, l, c, u) { const d = r.get(e); if (!d) return; const f = new Set, p = e => { e && e.forEach((e => { (e !== t || e.allowRecurse) && f.add(e) })) }; if ("clear" === i) d.forEach(p); else if ("length" === s && n.isArray(e)) d.forEach(((e, t) => { ("length" === t || t >= l) && p(e) })); else switch (void 0 !== s && p(d.get(s)), i) { case "add": n.isArray(e) ? n.isIntegerKey(s) && p(d.get("length")) : (p(d.get(o)), n.isMap(e) && p(d.get(a))); break; case "delete": n.isArray(e) || (p(d.get(o)), n.isMap(e) && p(d.get(a))); break; case "set": n.isMap(e) && p(d.get(o)) }f.forEach((t => { t.options.onTrigger && t.options.onTrigger({ effect: t, target: e, key: s, type: i, newValue: l, oldValue: c, oldTarget: u }), t.options.scheduler ? t.options.scheduler(t) : t() })) } var m = n.makeMap("__proto__,__v_isRef,__isVue"), v = new Set(Object.getOwnPropertyNames(Symbol).map((e => Symbol[e])).filter(n.isSymbol)), b = E(), y = E(!1, !0), x = E(!0), w = E(!0, !0), S = A(); function A() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach((t => { e[t] = function (...e) { const n = _e(this); for (let e = 0, t = this.length; e < t; e++)g(n, "get", e + ""); const r = n[t](...e); return -1 === r || !1 === r ? n[t](...e.map(_e)) : r } })), ["push", "pop", "shift", "unshift", "splice"].forEach((t => { e[t] = function (...e) { f(); const n = _e(this)[t].apply(this, e); return _(), n } })), e } function E(e = !1, t = !1) { return function (r, i, o) { if ("__v_isReactive" === i) return !e; if ("__v_isReadonly" === i) return e; if ("__v_raw" === i && o === (e ? t ? se : ae : t ? oe : ie).get(r)) return r; const a = n.isArray(r); if (!e && a && n.hasOwn(S, i)) return Reflect.get(S, i, o); const s = Reflect.get(r, i, o); if (n.isSymbol(i) ? v.has(i) : m(i)) return s; if (e || g(r, "get", i), t) return s; if (he(s)) { return !a || !n.isIntegerKey(i) ? s.value : s } return n.isObject(s) ? e ? ce(s) : le(s) : s } } var k = C(), O = C(!0); function C(e = !1) { return function (t, r, i, o) { let a = t[r]; if (!e && (i = _e(i), a = _e(a), !n.isArray(t) && he(a) && !he(i))) return a.value = i, !0; const s = n.isArray(t) && n.isIntegerKey(r) ? Number(r) < t.length : n.hasOwn(t, r), l = Reflect.set(t, r, i, o); return t === _e(o) && (s ? n.hasChanged(i, a) && h(t, "set", r, i, a) : h(t, "add", r, i)), l } } var T = { get: b, set: k, deleteProperty: function (e, t) { const r = n.hasOwn(e, t), i = e[t], o = Reflect.deleteProperty(e, t); return o && r && h(e, "delete", t, void 0, i), o }, has: function (e, t) { const r = Reflect.has(e, t); return n.isSymbol(t) && v.has(t) || g(e, "has", t), r }, ownKeys: function (e) { return g(e, "iterate", n.isArray(e) ? "length" : o), Reflect.ownKeys(e) } }, P = { get: x, set: (e, t) => (console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0), deleteProperty: (e, t) => (console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0) }, M = n.extend({}, T, { get: y, set: O }), j = n.extend({}, P, { get: w }), R = e => n.isObject(e) ? le(e) : e, N = e => n.isObject(e) ? ce(e) : e, D = e => e, F = e => Reflect.getPrototypeOf(e); function I(e, t, n = !1, r = !1) { const i = _e(e = e.__v_raw), o = _e(t); t !== o && !n && g(i, "get", t), !n && g(i, "get", o); const { has: a } = F(i), s = r ? D : n ? N : R; return a.call(i, t) ? s(e.get(t)) : a.call(i, o) ? s(e.get(o)) : void (e !== i && e.get(t)) } function L(e, t = !1) { const n = this.__v_raw, r = _e(n), i = _e(e); return e !== i && !t && g(r, "has", e), !t && g(r, "has", i), e === i ? n.has(e) : n.has(e) || n.has(i) } function $(e, t = !1) { return e = e.__v_raw, !t && g(_e(e), "iterate", o), Reflect.get(e, "size", e) } function B(e) { e = _e(e); const t = _e(this); return F(t).has.call(t, e) || (t.add(e), h(t, "add", e, e)), this } function q(e, t) { t = _e(t); const r = _e(this), { has: i, get: o } = F(r); let a = i.call(r, e); a ? re(r, i, e) : (e = _e(e), a = i.call(r, e)); const s = o.call(r, e); return r.set(e, t), a ? n.hasChanged(t, s) && h(r, "set", e, t, s) : h(r, "add", e, t), this } function H(e) { const t = _e(this), { has: n, get: r } = F(t); let i = n.call(t, e); i ? re(t, n, e) : (e = _e(e), i = n.call(t, e)); const o = r ? r.call(t, e) : void 0, a = t.delete(e); return i && h(t, "delete", e, void 0, o), a } function z() { const e = _e(this), t = 0 !== e.size, r = n.isMap(e) ? new Map(e) : new Set(e), i = e.clear(); return t && h(e, "clear", void 0, void 0, r), i } function V(e, t) { return function (n, r) { const i = this, a = i.__v_raw, s = _e(a), l = t ? D : e ? N : R; return !e && g(s, "iterate", o), a.forEach(((e, t) => n.call(r, l(e), l(t), i))) } } function U(e, t, r) { return function (...i) { const s = this.__v_raw, l = _e(s), c = n.isMap(l), u = "entries" === e || e === Symbol.iterator && c, d = "keys" === e && c, f = s[e](...i), p = r ? D : t ? N : R; return !t && g(l, "iterate", d ? a : o), { next() { const { value: e, done: t } = f.next(); return t ? { value: e, done: t } : { value: u ? [p(e[0]), p(e[1])] : p(e), done: t } }, [Symbol.iterator]() { return this } } } } function K(e) { return function (...t) { { const r = t[0] ? `on key "${t[0]}" ` : ""; console.warn(`${n.capitalize(e)} operation ${r}failed: target is readonly.`, _e(this)) } return "delete" !== e && this } } function J() { const e = { get(e) { return I(this, e) }, get size() { return $(this) }, has: L, add: B, set: q, delete: H, clear: z, forEach: V(!1, !1) }, t = { get(e) { return I(this, e, !1, !0) }, get size() { return $(this) }, has: L, add: B, set: q, delete: H, clear: z, forEach: V(!1, !0) }, n = { get(e) { return I(this, e, !0) }, get size() { return $(this, !0) }, has(e) { return L.call(this, e, !0) }, add: K("add"), set: K("set"), delete: K("delete"), clear: K("clear"), forEach: V(!0, !1) }, r = { get(e) { return I(this, e, !0, !0) }, get size() { return $(this, !0) }, has(e) { return L.call(this, e, !0) }, add: K("add"), set: K("set"), delete: K("delete"), clear: K("clear"), forEach: V(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach((i => { e[i] = U(i, !1, !1), n[i] = U(i, !0, !1), t[i] = U(i, !1, !0), r[i] = U(i, !0, !0) })), [e, n, t, r] } var [W, G, Y, X] = J(); function Z(e, t) { const r = t ? e ? X : Y : e ? G : W; return (t, i, o) => "__v_isReactive" === i ? !e : "__v_isReadonly" === i ? e : "__v_raw" === i ? t : Reflect.get(n.hasOwn(r, i) && i in t ? r : t, i, o) } var Q = { get: Z(!1, !1) }, ee = { get: Z(!1, !0) }, te = { get: Z(!0, !1) }, ne = { get: Z(!0, !0) }; function re(e, t, r) { const i = _e(r); if (i !== r && t.call(e, i)) { const t = n.toRawType(e); console.warn(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map" === t ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`) } } var ie = new WeakMap, oe = new WeakMap, ae = new WeakMap, se = new WeakMap; function le(e) { return e && e.__v_isReadonly ? e : ue(e, !1, T, Q, ie) } function ce(e) { return ue(e, !0, P, te, ae) } function ue(e, t, r, i, o) { if (!n.isObject(e)) return console.warn(`value cannot be made reactive: ${String(e)}`), e; if (e.__v_raw && (!t || !e.__v_isReactive)) return e; const a = o.get(e); if (a) return a; const s = (l = e).__v_skip || !Object.isExtensible(l) ? 0 : function (e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } }(n.toRawType(l)); var l; if (0 === s) return e; const c = new Proxy(e, 2 === s ? i : r); return o.set(e, c), c } function de(e) { return fe(e) ? de(e.__v_raw) : !(!e || !e.__v_isReactive) } function fe(e) { return !(!e || !e.__v_isReadonly) } function pe(e) { return de(e) || fe(e) } function _e(e) { return e && _e(e.__v_raw) || e } var ge = e => n.isObject(e) ? le(e) : e; function he(e) { return Boolean(e && !0 === e.__v_isRef) } function me(e, t = !1) { return he(e) ? e : new class { constructor(e, t = !1) { this._shallow = t, this.__v_isRef = !0, this._rawValue = t ? e : _e(e), this._value = t ? e : ge(e) } get value() { return g(_e(this), "get", "value"), this._value } set value(e) { e = this._shallow ? e : _e(e), n.hasChanged(e, this._rawValue) && (this._rawValue = e, this._value = this._shallow ? e : ge(e), h(_e(this), "set", "value", e)) } }(e, t) } function ve(e) { return he(e) ? e.value : e } var be = { get: (e, t, n) => ve(Reflect.get(e, t, n)), set: (e, t, n, r) => { const i = e[t]; return he(i) && !he(n) ? (i.value = n, !0) : Reflect.set(e, t, n, r) } }; function ye(e, t) { return he(e[t]) ? e[t] : new class { constructor(e, t) { this._object = e, this._key = t, this.__v_isRef = !0 } get value() { return this._object[this._key] } set value(e) { this._object[this._key] = e } }(e, t) } e.ITERATE_KEY = o, e.computed = function (e) { let t, r; return n.isFunction(e) ? (t = e, r = () => { console.warn("Write operation failed: computed value is readonly") }) : (t = e.get, r = e.set), new class { constructor(e, t, n) { this._setter = t, this._dirty = !0, this.__v_isRef = !0, this.effect = s(e, { lazy: !0, scheduler: () => { this._dirty || (this._dirty = !0, h(_e(this), "set", "value")) } }), this.__v_isReadonly = n } get value() { const e = _e(this); return e._dirty && (e._value = this.effect(), e._dirty = !1), g(e, "get", "value"), e._value } set value(e) { this._setter(e) } }(t, r, n.isFunction(e) || !e.set) }, e.customRef = function (e) { return new class { constructor(e) { this.__v_isRef = !0; const { get: t, set: n } = e((() => g(this, "get", "value")), (() => h(this, "set", "value"))); this._get = t, this._set = n } get value() { return this._get() } set value(e) { this._set(e) } }(e) }, e.effect = s, e.enableTracking = p, e.isProxy = pe, e.isReactive = de, e.isReadonly = fe, e.isRef = he, e.markRaw = function (e) { return n.def(e, "__v_skip", !0), e }, e.pauseTracking = f, e.proxyRefs = function (e) { return de(e) ? e : new Proxy(e, be) }, e.reactive = le, e.readonly = ce, e.ref = function (e) { return me(e) }, e.resetTracking = _, e.shallowReactive = function (e) { return ue(e, !1, M, ee, oe) }, e.shallowReadonly = function (e) { return ue(e, !0, j, ne, se) }, e.shallowRef = function (e) { return me(e, !0) }, e.stop = function (e) { e.active && (c(e), e.options.onStop && e.options.onStop(), e.active = !1) }, e.toRaw = _e, e.toRef = ye, e.toRefs = function (e) { pe(e) || console.warn("toRefs() expects a reactive object but received a plain one."); const t = n.isArray(e) ? new Array(e.length) : {}; for (const n in e) t[n] = ye(e, n); return t }, e.track = g, e.trigger = h, e.triggerRef = function (e) { h(_e(e), "set", "value", e.value) }, e.unref = ve } }), require_reactivity = __commonJS({ "node_modules/@vue/reactivity/index.js"(e, t) { "use strict"; t.exports = require_reactivity_cjs() } }), module_exports = {}; __export(module_exports, { Alpine: () => src_default, default: () => module_default }), module.exports = __toCommonJS(module_exports); var reactive, effect, release, raw, flushPending = !1, flushing = !1, queue = [], lastFlushedIndex = -1; function scheduler(e) { queueJob(e) } function queueJob(e) { queue.includes(e) || queue.push(e), queueFlush() } function dequeueJob(e) { let t = queue.indexOf(e); -1 !== t && t > lastFlushedIndex && queue.splice(t, 1) } function queueFlush() { flushing || flushPending || (flushPending = !0, queueMicrotask(flushJobs)) } function flushJobs() { flushPending = !1, flushing = !0; for (let e = 0; e < queue.length; e++)queue[e](), lastFlushedIndex = e; queue.length = 0, lastFlushedIndex = -1, flushing = !1 } var shouldSchedule = !0; function disableEffectScheduling(e) { shouldSchedule = !1, e(), shouldSchedule = !0 } function setReactivityEngine(e) { reactive = e.reactive, release = e.release, effect = t => e.effect(t, { scheduler: e => { shouldSchedule ? scheduler(e) : e() } }), raw = e.raw } function overrideEffect(e) { effect = e } function elementBoundEffect(e) { let t = () => { }; return [n => { let r = effect(n); return e._x_effects || (e._x_effects = new Set, e._x_runEffects = () => { e._x_effects.forEach((e => e())) }), e._x_effects.add(r), t = () => { void 0 !== r && (e._x_effects.delete(r), release(r)) }, r }, () => { t() }] } function watch(e, t) { let n, r = !0, i = effect((() => { let i = e(); JSON.stringify(i), r ? n = i : queueMicrotask((() => { t(i, n), n = i })), r = !1 })); return () => release(i) } function dispatch(e, t, n = {}) { e.dispatchEvent(new CustomEvent(t, { detail: n, bubbles: !0, composed: !0, cancelable: !0 })) } function walk(e, t) { if ("function" == typeof ShadowRoot && e instanceof ShadowRoot) return void Array.from(e.children).forEach((e => walk(e, t))); let n = !1; if (t(e, (() => n = !0)), n) return; let r = e.firstElementChild; for (; r;)walk(r, t, !1), r = r.nextElementSibling } function warn(e, ...t) { console.warn(`Alpine Warning: ${e}`, ...t) } var started = !1; function start() { started && warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."), started = !0, document.body || warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), dispatch(document, "alpine:init"), dispatch(document, "alpine:initializing"), startObservingMutations(), onElAdded((e => initTree(e, walk))), onElRemoved((e => destroyTree(e))), onAttributesAdded(((e, t) => { directives(e, t).forEach((e => e())) })); Array.from(document.querySelectorAll(allSelectors().join(","))).filter((e => !closestRoot(e.parentElement, !0))).forEach((e => { initTree(e) })), dispatch(document, "alpine:initialized") } var rootSelectorCallbacks = [], initSelectorCallbacks = []; function rootSelectors() { return rootSelectorCallbacks.map((e => e())) } function allSelectors() { return rootSelectorCallbacks.concat(initSelectorCallbacks).map((e => e())) } function addRootSelector(e) { rootSelectorCallbacks.push(e) } function addInitSelector(e) { initSelectorCallbacks.push(e) } function closestRoot(e, t = !1) { return findClosest(e, (e => { if ((t ? allSelectors() : rootSelectors()).some((t => e.matches(t)))) return !0 })) } function findClosest(e, t) { if (e) { if (t(e)) return e; if (e._x_teleportBack && (e = e._x_teleportBack), e.parentElement) return findClosest(e.parentElement, t) } } function isRoot(e) { return rootSelectors().some((t => e.matches(t))) } var initInterceptors = []; function interceptInit(e) { initInterceptors.push(e) } function initTree(e, t = walk, n = (() => { })) { deferHandlingDirectives((() => { t(e, ((e, t) => { n(e, t), initInterceptors.forEach((n => n(e, t))), directives(e, e.attributes).forEach((e => e())), e._x_ignore && t() })) })) } function destroyTree(e) { walk(e, (e => { cleanupAttributes(e), cleanupElement(e) })) } var onAttributeAddeds = [], onElRemoveds = [], onElAddeds = []; function onElAdded(e) { onElAddeds.push(e) } function onElRemoved(e, t) { "function" == typeof t ? (e._x_cleanups || (e._x_cleanups = []), e._x_cleanups.push(t)) : (t = e, onElRemoveds.push(t)) } function onAttributesAdded(e) { onAttributeAddeds.push(e) } function onAttributeRemoved(e, t, n) { e._x_attributeCleanups || (e._x_attributeCleanups = {}), e._x_attributeCleanups[t] || (e._x_attributeCleanups[t] = []), e._x_attributeCleanups[t].push(n) } function cleanupAttributes(e, t) { e._x_attributeCleanups && Object.entries(e._x_attributeCleanups).forEach((([n, r]) => { (void 0 === t || t.includes(n)) && (r.forEach((e => e())), delete e._x_attributeCleanups[n]) })) } function cleanupElement(e) { if (e._x_cleanups) for (; e._x_cleanups.length;)e._x_cleanups.pop()() } var observer = new MutationObserver(onMutate), currentlyObserving = !1; function startObservingMutations() { observer.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), currentlyObserving = !0 } function stopObservingMutations() { flushObserver(), observer.disconnect(), currentlyObserving = !1 } var queuedMutations = []; function flushObserver() { let e = observer.takeRecords(); queuedMutations.push((() => e.length > 0 && onMutate(e))); let t = queuedMutations.length; queueMicrotask((() => { if (queuedMutations.length === t) for (; queuedMutations.length > 0;)queuedMutations.shift()() })) } function mutateDom(e) { if (!currentlyObserving) return e(); stopObservingMutations(); let t = e(); return startObservingMutations(), t } var isCollecting = !1, deferredMutations = []; function deferMutations() { isCollecting = !0 } function flushAndStopDeferringMutations() { isCollecting = !1, onMutate(deferredMutations), deferredMutations = [] } function onMutate(e) { if (isCollecting) return void (deferredMutations = deferredMutations.concat(e)); let t = new Set, n = new Set, r = new Map, i = new Map; for (let o = 0; o < e.length; o++)if (!e[o].target._x_ignoreMutationObserver && ("childList" === e[o].type && (e[o].addedNodes.forEach((e => 1 === e.nodeType && t.add(e))), e[o].removedNodes.forEach((e => 1 === e.nodeType && n.add(e)))), "attributes" === e[o].type)) { let t = e[o].target, n = e[o].attributeName, a = e[o].oldValue, s = () => { r.has(t) || r.set(t, []), r.get(t).push({ name: n, value: t.getAttribute(n) }) }, l = () => { i.has(t) || i.set(t, []), i.get(t).push(n) }; t.hasAttribute(n) && null === a ? s() : t.hasAttribute(n) ? (l(), s()) : l() } i.forEach(((e, t) => { cleanupAttributes(t, e) })), r.forEach(((e, t) => { onAttributeAddeds.forEach((n => n(t, e))) })); for (let e of n) t.has(e) || (onElRemoveds.forEach((t => t(e))), destroyTree(e)); t.forEach((e => { e._x_ignoreSelf = !0, e._x_ignore = !0 })); for (let e of t) n.has(e) || e.isConnected && (delete e._x_ignoreSelf, delete e._x_ignore, onElAddeds.forEach((t => t(e))), e._x_ignore = !0, e._x_ignoreSelf = !0); t.forEach((e => { delete e._x_ignoreSelf, delete e._x_ignore })), t = null, n = null, r = null, i = null } function scope(e) { return mergeProxies(closestDataStack(e)) } function addScopeToNode(e, t, n) { return e._x_dataStack = [t, ...closestDataStack(n || e)], () => { e._x_dataStack = e._x_dataStack.filter((e => e !== t)) } } function closestDataStack(e) { return e._x_dataStack ? e._x_dataStack : "function" == typeof ShadowRoot && e instanceof ShadowRoot ? closestDataStack(e.host) : e.parentNode ? closestDataStack(e.parentNode) : [] } function mergeProxies(e) { return new Proxy({ objects: e }, mergeProxyTrap) } var mergeProxyTrap = { ownKeys: ({ objects: e }) => Array.from(new Set(e.flatMap((e => Object.keys(e))))), has: ({ objects: e }, t) => t != Symbol.unscopables && e.some((e => Object.prototype.hasOwnProperty.call(e, t))), get: ({ objects: e }, t, n) => "toJSON" == t ? collapseProxies : Reflect.get(e.find((e => Object.prototype.hasOwnProperty.call(e, t))) || {}, t, n), set({ objects: e }, t, n, r) { const i = e.find((e => Object.prototype.hasOwnProperty.call(e, t))) || e[e.length - 1], o = Object.getOwnPropertyDescriptor(i, t); return (null == o ? void 0 : o.set) && (null == o ? void 0 : o.get) ? Reflect.set(i, t, n, r) : Reflect.set(i, t, n) } }; function collapseProxies() { return Reflect.ownKeys(this).reduce(((e, t) => (e[t] = Reflect.get(this, t), e)), {}) } function initInterceptors2(e) { let t = (n, r = "") => { Object.entries(Object.getOwnPropertyDescriptors(n)).forEach((([i, { value: o, enumerable: a }]) => { if (!1 === a || void 0 === o) return; let s = "" === r ? i : `${r}.${i}`; var l; "object" == typeof o && null !== o && o._x_interceptor ? n[i] = o.initialize(e, s, i) : "object" != typeof (l = o) || Array.isArray(l) || null === l || o === n || o instanceof Element || t(o, s) })) }; return t(e) } function interceptor(e, t = (() => { })) { let n = { initialValue: void 0, _x_interceptor: !0, initialize(t, n, r) { return e(this.initialValue, (() => get(t, n)), (e => set(t, n, e)), n, r) } }; return t(n), e => { if ("object" == typeof e && null !== e && e._x_interceptor) { let t = n.initialize.bind(n); n.initialize = (r, i, o) => { let a = e.initialize(r, i, o); return n.initialValue = a, t(r, i, o) } } else n.initialValue = e; return n } } function get(e, t) { return t.split(".").reduce(((e, t) => e[t]), e) } function set(e, t, n) { if ("string" == typeof t && (t = t.split(".")), 1 !== t.length) { if (0 === t.length) throw error; return e[t[0]] || (e[t[0]] = {}), set(e[t[0]], t.slice(1), n) } e[t[0]] = n } var magics = {}; function magic(e, t) { magics[e] = t } function injectMagics(e, t) { return Object.entries(magics).forEach((([n, r]) => { let i = null; Object.defineProperty(e, `$${n}`, { get: () => r(t, function () { if (i) return i; { let [e, n] = getElementBoundUtilities(t); return i = { interceptor: interceptor, ...e }, onElRemoved(t, n), i } }()), enumerable: !1 }) })), e } function tryCatch(e, t, n, ...r) { try { return n(...r) } catch (n) { handleError(n, e, t) } } function handleError(e, t, n = void 0) { e = Object.assign(null != e ? e : { message: "No error message given." }, { el: t, expression: n }), console.warn(`Alpine Expression Error: ${e.message}\n\n${n ? 'Expression: "' + n + '"\n\n' : ""}`, t), setTimeout((() => { throw e }), 0) } var shouldAutoEvaluateFunctions = !0; function dontAutoEvaluateFunctions(e) { let t = shouldAutoEvaluateFunctions; shouldAutoEvaluateFunctions = !1; let n = e(); return shouldAutoEvaluateFunctions = t, n } function evaluate(e, t, n = {}) { let r; return evaluateLater(e, t)((e => r = e), n), r } function evaluateLater(...e) { return theEvaluatorFunction(...e) } var theEvaluatorFunction = normalEvaluator; function setEvaluator(e) { theEvaluatorFunction = e } function normalEvaluator(e, t) { let n = {}; injectMagics(n, e); let r = [n, ...closestDataStack(e)], i = "function" == typeof t ? generateEvaluatorFromFunction(r, t) : generateEvaluatorFromString(r, t, e); return tryCatch.bind(null, e, t, i) } function generateEvaluatorFromFunction(e, t) { return (n = (() => { }), { scope: r = {}, params: i = [] } = {}) => { runIfTypeOfFunction(n, t.apply(mergeProxies([r, ...e]), i)) } } var evaluatorMemo = {}; function generateFunctionFromString(e, t) { if (evaluatorMemo[e]) return evaluatorMemo[e]; let n = Object.getPrototypeOf((async function () { })).constructor, r = /^[\n\s]*if.*\(.*\)/.test(e.trim()) || /^(let|const)\s/.test(e.trim()) ? `(async()=>{ ${e} })()` : e; let i = (() => { try { let t = new n(["__self", "scope"], `with (scope) { __self.result = ${r} }; __self.finished = true; return __self.result;`); return Object.defineProperty(t, "name", { value: `[Alpine] ${e}` }), t } catch (n) { return handleError(n, t, e), Promise.resolve() } })(); return evaluatorMemo[e] = i, i } function generateEvaluatorFromString(e, t, n) { let r = generateFunctionFromString(t, n); return (i = (() => { }), { scope: o = {}, params: a = [] } = {}) => { r.result = void 0, r.finished = !1; let s = mergeProxies([o, ...e]); if ("function" == typeof r) { let e = r(r, s).catch((e => handleError(e, n, t))); r.finished ? (runIfTypeOfFunction(i, r.result, s, a, n), r.result = void 0) : e.then((e => { runIfTypeOfFunction(i, e, s, a, n) })).catch((e => handleError(e, n, t))).finally((() => r.result = void 0)) } } } function runIfTypeOfFunction(e, t, n, r, i) { if (shouldAutoEvaluateFunctions && "function" == typeof t) { let o = t.apply(n, r); o instanceof Promise ? o.then((t => runIfTypeOfFunction(e, t, n, r))).catch((e => handleError(e, i, t))) : e(o) } else "object" == typeof t && t instanceof Promise ? t.then((t => e(t))) : e(t) } var prefixAsString = "x-"; function prefix(e = "") { return prefixAsString + e } function setPrefix(e) { prefixAsString = e } var directiveHandlers = {}; function directive(e, t) { return directiveHandlers[e] = t, { before(t) { if (!directiveHandlers[t]) return void console.warn(String.raw`Cannot find directive \`${t}\`. \`${e}\` will use the default order of execution`); const n = directiveOrder.indexOf(t); directiveOrder.splice(n >= 0 ? n : directiveOrder.indexOf("DEFAULT"), 0, e) } } } function directives(e, t, n) { if (t = Array.from(t), e._x_virtualDirectives) { let n = Object.entries(e._x_virtualDirectives).map((([e, t]) => ({ name: e, value: t }))), r = attributesOnly(n); n = n.map((e => r.find((t => t.name === e.name)) ? { name: `x-bind:${e.name}`, value: `"${e.value}"` } : e)), t = t.concat(n) } let r = {}; return t.map(toTransformedAttributes(((e, t) => r[e] = t))).filter(outNonAlpineAttributes).map(toParsedDirectives(r, n)).sort(byPriority).map((t => getDirectiveHandler(e, t))) } function attributesOnly(e) { return Array.from(e).map(toTransformedAttributes()).filter((e => !outNonAlpineAttributes(e))) } var isDeferringHandlers = !1, directiveHandlerStacks = new Map, currentHandlerStackKey = Symbol(); function deferHandlingDirectives(e) { isDeferringHandlers = !0; let t = Symbol(); currentHandlerStackKey = t, directiveHandlerStacks.set(t, []); let n = () => { for (; directiveHandlerStacks.get(t).length;)directiveHandlerStacks.get(t).shift()(); directiveHandlerStacks.delete(t) }; e(n), isDeferringHandlers = !1, n() } function getElementBoundUtilities(e) { let t = [], [n, r] = elementBoundEffect(e); t.push(r); return [{ Alpine: alpine_default, effect: n, cleanup: e => t.push(e), evaluateLater: evaluateLater.bind(evaluateLater, e), evaluate: evaluate.bind(evaluate, e) }, () => t.forEach((e => e()))] } function getDirectiveHandler(e, t) { let n = directiveHandlers[t.type] || (() => { }), [r, i] = getElementBoundUtilities(e); onAttributeRemoved(e, t.original, i); let o = () => { e._x_ignore || e._x_ignoreSelf || (n.inline && n.inline(e, t, r), n = n.bind(n, e, t, r), isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(n) : n()) }; return o.runCleanups = i, o } var startingWith = (e, t) => ({ name: n, value: r }) => (n.startsWith(e) && (n = n.replace(e, t)), { name: n, value: r }), into = e => e; function toTransformedAttributes(e = (() => { })) { return ({ name: t, value: n }) => { let { name: r, value: i } = attributeTransformers.reduce(((e, t) => t(e)), { name: t, value: n }); return r !== t && e(r, t), { name: r, value: i } } } var attributeTransformers = []; function mapAttributes(e) { attributeTransformers.push(e) } function outNonAlpineAttributes({ name: e }) { return alpineAttributeRegex().test(e) } var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`); function toParsedDirectives(e, t) { return ({ name: n, value: r }) => { let i = n.match(alpineAttributeRegex()), o = n.match(/:([a-zA-Z0-9\-_:]+)/), a = n.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], s = t || e[n] || n; return { type: i ? i[1] : null, value: o ? o[1] : null, modifiers: a.map((e => e.replace(".", ""))), expression: r, original: s } } } var DEFAULT = "DEFAULT", directiveOrder = ["ignore", "ref", "data", "id", "anchor", "bind", "init", "for", "model", "modelable", "transition", "show", "if", DEFAULT, "teleport"]; function byPriority(e, t) { let n = -1 === directiveOrder.indexOf(e.type) ? DEFAULT : e.type, r = -1 === directiveOrder.indexOf(t.type) ? DEFAULT : t.type; return directiveOrder.indexOf(n) - directiveOrder.indexOf(r) } var tickStack = [], isHolding = !1; function nextTick(e = (() => { })) { return queueMicrotask((() => { isHolding || setTimeout((() => { releaseNextTicks() })) })), new Promise((t => { tickStack.push((() => { e(), t() })) })) } function releaseNextTicks() { for (isHolding = !1; tickStack.length;)tickStack.shift()() } function holdNextTicks() { isHolding = !0 } function setClasses(e, t) { return Array.isArray(t) ? setClassesFromString(e, t.join(" ")) : "object" == typeof t && null !== t ? setClassesFromObject(e, t) : "function" == typeof t ? setClasses(e, t()) : setClassesFromString(e, t) } function setClassesFromString(e, t) { return t = !0 === t ? t = "" : t || "", n = t.split(" ").filter((t => !e.classList.contains(t))).filter(Boolean), e.classList.add(...n), () => { e.classList.remove(...n) }; var n } function setClassesFromObject(e, t) { let n = e => e.split(" ").filter(Boolean), r = Object.entries(t).flatMap((([e, t]) => !!t && n(e))).filter(Boolean), i = Object.entries(t).flatMap((([e, t]) => !t && n(e))).filter(Boolean), o = [], a = []; return i.forEach((t => { e.classList.contains(t) && (e.classList.remove(t), a.push(t)) })), r.forEach((t => { e.classList.contains(t) || (e.classList.add(t), o.push(t)) })), () => { a.forEach((t => e.classList.add(t))), o.forEach((t => e.classList.remove(t))) } } function setStyles(e, t) { return "object" == typeof t && null !== t ? setStylesFromObject(e, t) : setStylesFromString(e, t) } function setStylesFromObject(e, t) { let n = {}; return Object.entries(t).forEach((([t, r]) => { n[t] = e.style[t], t.startsWith("--") || (t = kebabCase(t)), e.style.setProperty(t, r) })), setTimeout((() => { 0 === e.style.length && e.removeAttribute("style") })), () => { setStyles(e, n) } } function setStylesFromString(e, t) { let n = e.getAttribute("style", t); return e.setAttribute("style", t), () => { e.setAttribute("style", n || "") } } function kebabCase(e) { return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function once(e, t = (() => { })) { let n = !1; return function () { n ? t.apply(this, arguments) : (n = !0, e.apply(this, arguments)) } } function registerTransitionsFromClassString(e, t, n) { registerTransitionObject(e, setClasses, ""), { enter: t => { e._x_transition.enter.during = t }, "enter-start": t => { e._x_transition.enter.start = t }, "enter-end": t => { e._x_transition.enter.end = t }, leave: t => { e._x_transition.leave.during = t }, "leave-start": t => { e._x_transition.leave.start = t }, "leave-end": t => { e._x_transition.leave.end = t } }[n](t) } function registerTransitionsFromHelper(e, t, n) { registerTransitionObject(e, setStyles); let r = !t.includes("in") && !t.includes("out") && !n, i = r || t.includes("in") || ["enter"].includes(n), o = r || t.includes("out") || ["leave"].includes(n); t.includes("in") && !r && (t = t.filter(((e, n) => n < t.indexOf("out")))), t.includes("out") && !r && (t = t.filter(((e, n) => n > t.indexOf("out")))); let a = !t.includes("opacity") && !t.includes("scale"), s = a || t.includes("opacity") ? 0 : 1, l = a || t.includes("scale") ? modifierValue(t, "scale", 95) / 100 : 1, c = modifierValue(t, "delay", 0) / 1e3, u = modifierValue(t, "origin", "center"), d = "opacity, transform", f = modifierValue(t, "duration", 150) / 1e3, p = modifierValue(t, "duration", 75) / 1e3, _ = "cubic-bezier(0.4, 0.0, 0.2, 1)"; i && (e._x_transition.enter.during = { transformOrigin: u, transitionDelay: `${c}s`, transitionProperty: d, transitionDuration: `${f}s`, transitionTimingFunction: _ }, e._x_transition.enter.start = { opacity: s, transform: `scale(${l})` }, e._x_transition.enter.end = { opacity: 1, transform: "scale(1)" }), o && (e._x_transition.leave.during = { transformOrigin: u, transitionDelay: `${c}s`, transitionProperty: d, transitionDuration: `${p}s`, transitionTimingFunction: _ }, e._x_transition.leave.start = { opacity: 1, transform: "scale(1)" }, e._x_transition.leave.end = { opacity: s, transform: `scale(${l})` }) } function registerTransitionObject(e, t, n = {}) { e._x_transition || (e._x_transition = { enter: { during: n, start: n, end: n }, leave: { during: n, start: n, end: n }, in(n = (() => { }), r = (() => { })) { transition(e, t, { during: this.enter.during, start: this.enter.start, end: this.enter.end }, n, r) }, out(n = (() => { }), r = (() => { })) { transition(e, t, { during: this.leave.during, start: this.leave.start, end: this.leave.end }, n, r) } }) } function closestHide(e) { let t = e.parentNode; if (t) return t._x_hidePromise ? t : closestHide(t) } function transition(e, t, { during: n, start: r, end: i } = {}, o = (() => { }), a = (() => { })) { if (e._x_transitioning && e._x_transitioning.cancel(), 0 === Object.keys(n).length && 0 === Object.keys(r).length && 0 === Object.keys(i).length) return o(), void a(); let s, l, c; performTransition(e, { start() { s = t(e, r) }, during() { l = t(e, n) }, before: o, end() { s(), c = t(e, i) }, after: a, cleanup() { l(), c() } }) } function performTransition(e, t) { let n, r, i, o = once((() => { mutateDom((() => { n = !0, r || t.before(), i || (t.end(), releaseNextTicks()), t.after(), e.isConnected && t.cleanup(), delete e._x_transitioning })) })); e._x_transitioning = { beforeCancels: [], beforeCancel(e) { this.beforeCancels.push(e) }, cancel: once((function () { for (; this.beforeCancels.length;)this.beforeCancels.shift()(); o() })), finish: o }, mutateDom((() => { t.start(), t.during() })), holdNextTicks(), requestAnimationFrame((() => { if (n) return; let o = 1e3 * Number(getComputedStyle(e).transitionDuration.replace(/,.*/, "").replace("s", "")), a = 1e3 * Number(getComputedStyle(e).transitionDelay.replace(/,.*/, "").replace("s", "")); 0 === o && (o = 1e3 * Number(getComputedStyle(e).animationDuration.replace("s", ""))), mutateDom((() => { t.before() })), r = !0, requestAnimationFrame((() => { n || (mutateDom((() => { t.end() })), releaseNextTicks(), setTimeout(e._x_transitioning.finish, o + a), i = !0) })) })) } function modifierValue(e, t, n) { if (-1 === e.indexOf(t)) return n; const r = e[e.indexOf(t) + 1]; if (!r) return n; if ("scale" === t && isNaN(r)) return n; if ("duration" === t || "delay" === t) { let e = r.match(/([0-9]+)ms/); if (e) return e[1] } return "origin" === t && ["top", "right", "left", "center", "bottom"].includes(e[e.indexOf(t) + 2]) ? [r, e[e.indexOf(t) + 2]].join(" ") : r } directive("transition", ((e, { value: t, modifiers: n, expression: r }, { evaluate: i }) => { "function" == typeof r && (r = i(r)), !1 !== r && (r && "boolean" != typeof r ? registerTransitionsFromClassString(e, r, t) : registerTransitionsFromHelper(e, n, t)) })), window.Element.prototype._x_toggleAndCascadeWithTransitions = function (e, t, n, r) { const i = "visible" === document.visibilityState ? requestAnimationFrame : setTimeout; let o = () => i(n); t ? e._x_transition && (e._x_transition.enter || e._x_transition.leave) ? e._x_transition.enter && (Object.entries(e._x_transition.enter.during).length || Object.entries(e._x_transition.enter.start).length || Object.entries(e._x_transition.enter.end).length) ? e._x_transition.in(n) : o() : e._x_transition ? e._x_transition.in(n) : o() : (e._x_hidePromise = e._x_transition ? new Promise(((t, n) => { e._x_transition.out((() => { }), (() => t(r))), e._x_transitioning && e._x_transitioning.beforeCancel((() => n({ isFromCancelledTransition: !0 }))) })) : Promise.resolve(r), queueMicrotask((() => { let t = closestHide(e); t ? (t._x_hideChildren || (t._x_hideChildren = []), t._x_hideChildren.push(e)) : i((() => { let t = e => { let n = Promise.all([e._x_hidePromise, ...(e._x_hideChildren || []).map(t)]).then((([e]) => e())); return delete e._x_hidePromise, delete e._x_hideChildren, n }; t(e).catch((e => { if (!e.isFromCancelledTransition) throw e })) })) }))) }; var isCloning = !1; function skipDuringClone(e, t = (() => { })) { return (...n) => isCloning ? t(...n) : e(...n) } function onlyDuringClone(e) { return (...t) => isCloning && e(...t) } var interceptors = []; function interceptClone(e) { interceptors.push(e) } function cloneNode(e, t) { interceptors.forEach((n => n(e, t))), isCloning = !0, dontRegisterReactiveSideEffects((() => { initTree(t, ((e, t) => { t(e, (() => { })) })) })), isCloning = !1 } var isCloningLegacy = !1; function clone(e, t) { t._x_dataStack || (t._x_dataStack = e._x_dataStack), isCloning = !0, isCloningLegacy = !0, dontRegisterReactiveSideEffects((() => { cloneTree(t) })), isCloning = !1, isCloningLegacy = !1 } function cloneTree(e) { let t = !1; initTree(e, ((e, n) => { walk(e, ((e, r) => { if (t && isRoot(e)) return r(); t = !0, n(e, r) })) })) } function dontRegisterReactiveSideEffects(e) { let t = effect; overrideEffect(((e, n) => { let r = t(e); return release(r), () => { } })), e(), overrideEffect(t) } function bind(e, t, n, r = []) { switch (e._x_bindings || (e._x_bindings = reactive({})), e._x_bindings[t] = n, t = r.includes("camel") ? camelCase(t) : t) { case "value": bindInputValue(e, n); break; case "style": bindStyles(e, n); break; case "class": bindClasses(e, n); break; case "selected": case "checked": bindAttributeAndProperty(e, t, n); break; default: bindAttribute(e, t, n) } } function bindInputValue(e, t) { if ("radio" === e.type) void 0 === e.attributes.value && (e.value = t), window.fromModel && (e.checked = "boolean" == typeof t ? safeParseBoolean(e.value) === t : checkedAttrLooseCompare(e.value, t)); else if ("checkbox" === e.type) Number.isInteger(t) ? e.value = t : Array.isArray(t) || "boolean" == typeof t || [null, void 0].includes(t) ? Array.isArray(t) ? e.checked = t.some((t => checkedAttrLooseCompare(t, e.value))) : e.checked = !!t : e.value = String(t); else if ("SELECT" === e.tagName) updateSelect(e, t); else { if (e.value === t) return; e.value = void 0 === t ? "" : t } } function bindClasses(e, t) { e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedClasses = setClasses(e, t) } function bindStyles(e, t) { e._x_undoAddedStyles && e._x_undoAddedStyles(), e._x_undoAddedStyles = setStyles(e, t) } function bindAttributeAndProperty(e, t, n) { bindAttribute(e, t, n), setPropertyIfChanged(e, t, n) } function bindAttribute(e, t, n) { [null, void 0, !1].includes(n) && attributeShouldntBePreservedIfFalsy(t) ? e.removeAttribute(t) : (isBooleanAttr(t) && (n = t), setIfChanged(e, t, n)) } function setIfChanged(e, t, n) { e.getAttribute(t) != n && e.setAttribute(t, n) } function setPropertyIfChanged(e, t, n) { e[t] !== n && (e[t] = n) } function updateSelect(e, t) { const n = [].concat(t).map((e => e + "")); Array.from(e.options).forEach((e => { e.selected = n.includes(e.value) })) } function camelCase(e) { return e.toLowerCase().replace(/-(\w)/g, ((e, t) => t.toUpperCase())) } function checkedAttrLooseCompare(e, t) { return e == t } function safeParseBoolean(e) { return !![1, "1", "true", "on", "yes", !0].includes(e) || ![0, "0", "false", "off", "no", !1].includes(e) && (e ? Boolean(e) : null) } function isBooleanAttr(e) { return ["disabled", "checked", "required", "readonly", "hidden", "open", "selected", "autofocus", "itemscope", "multiple", "novalidate", "allowfullscreen", "allowpaymentrequest", "formnovalidate", "autoplay", "controls", "loop", "muted", "playsinline", "default", "ismap", "reversed", "async", "defer", "nomodule"].includes(e) } function attributeShouldntBePreservedIfFalsy(e) { return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(e) } function getBinding(e, t, n) { return e._x_bindings && void 0 !== e._x_bindings[t] ? e._x_bindings[t] : getAttributeBinding(e, t, n) } function extractProp(e, t, n, r = !0) { if (e._x_bindings && void 0 !== e._x_bindings[t]) return e._x_bindings[t]; if (e._x_inlineBindings && void 0 !== e._x_inlineBindings[t]) { let n = e._x_inlineBindings[t]; return n.extract = r, dontAutoEvaluateFunctions((() => evaluate(e, n.expression))) } return getAttributeBinding(e, t, n) } function getAttributeBinding(e, t, n) { let r = e.getAttribute(t); return null === r ? "function" == typeof n ? n() : n : "" === r || (isBooleanAttr(t) ? !![t, "true"].includes(r) : r) } function debounce(e, t) { var n; return function () { var r = this, i = arguments; clearTimeout(n), n = setTimeout((function () { n = null, e.apply(r, i) }), t) } } function throttle(e, t) { let n; return function () { let r = this, i = arguments; n || (e.apply(r, i), n = !0, setTimeout((() => n = !1), t)) } } function entangle({ get: e, set: t }, { get: n, set: r }) { let i, o, a = !0, s = effect((() => { let s = e(), l = n(); if (a) r(cloneIfObject(s)), a = !1; else { let e = JSON.stringify(s), n = JSON.stringify(l); e !== i ? r(cloneIfObject(s)) : e !== n && t(cloneIfObject(l)) } i = JSON.stringify(e()), o = JSON.stringify(n()) })); return () => { release(s) } } function cloneIfObject(e) { return "object" == typeof e ? JSON.parse(JSON.stringify(e)) : e } function plugin(e) { (Array.isArray(e) ? e : [e]).forEach((e => e(alpine_default))) } var stores = {}, isReactive = !1; function store(e, t) { if (isReactive || (stores = reactive(stores), isReactive = !0), void 0 === t) return stores[e]; stores[e] = t, "object" == typeof t && null !== t && t.hasOwnProperty("init") && "function" == typeof t.init && stores[e].init(), initInterceptors2(stores[e]) } function getStores() { return stores } var binds = {}; function bind2(e, t) { let n = "function" != typeof t ? () => t : t; return e instanceof Element ? applyBindingsObject(e, n()) : (binds[e] = n, () => { }) } function injectBindingProviders(e) { return Object.entries(binds).forEach((([t, n]) => { Object.defineProperty(e, t, { get: () => (...e) => n(...e) }) })), e } function applyBindingsObject(e, t, n) { let r = []; for (; r.length;)r.pop()(); let i = Object.entries(t).map((([e, t]) => ({ name: e, value: t }))), o = attributesOnly(i); return i = i.map((e => o.find((t => t.name === e.name)) ? { name: `x-bind:${e.name}`, value: `"${e.value}"` } : e)), directives(e, i, n).map((e => { r.push(e.runCleanups), e() })), () => { for (; r.length;)r.pop()() } } var datas = {}; function data(e, t) { datas[e] = t } function injectDataProviders(e, t) { return Object.entries(datas).forEach((([n, r]) => { Object.defineProperty(e, n, { get: () => (...e) => r.bind(t)(...e), enumerable: !1 }) })), e } var Alpine = { get reactive() { return reactive }, get release() { return release }, get effect() { return effect }, get raw() { return raw }, version: "3.13.5", flushAndStopDeferringMutations: flushAndStopDeferringMutations, dontAutoEvaluateFunctions: dontAutoEvaluateFunctions, disableEffectScheduling: disableEffectScheduling, startObservingMutations: startObservingMutations, stopObservingMutations: stopObservingMutations, setReactivityEngine: setReactivityEngine, onAttributeRemoved: onAttributeRemoved, onAttributesAdded: onAttributesAdded, closestDataStack: closestDataStack, skipDuringClone: skipDuringClone, onlyDuringClone: onlyDuringClone, addRootSelector: addRootSelector, addInitSelector: addInitSelector, interceptClone: interceptClone, addScopeToNode: addScopeToNode, deferMutations: deferMutations, mapAttributes: mapAttributes, evaluateLater: evaluateLater, interceptInit: interceptInit, setEvaluator: setEvaluator, mergeProxies: mergeProxies, extractProp: extractProp, findClosest: findClosest, onElRemoved: onElRemoved, closestRoot: closestRoot, destroyTree: destroyTree, interceptor: interceptor, transition: transition, setStyles: setStyles, mutateDom: mutateDom, directive: directive, entangle: entangle, throttle: throttle, debounce: debounce, evaluate: evaluate, initTree: initTree, nextTick: nextTick, prefixed: prefix, prefix: setPrefix, plugin: plugin, magic: magic, store: store, start: start, clone: clone, cloneNode: cloneNode, bound: getBinding, $data: scope, watch: watch, walk: walk, data: data, bind: bind2 }, alpine_default = Alpine, import_reactivity10 = __toESM(require_reactivity()); function getArrayOfRefObject(e) { let t = [], n = e; for (; n;)n._x_refs && t.push(n._x_refs), n = n.parentNode; return t } magic("nextTick", (() => nextTick)), magic("dispatch", (e => dispatch.bind(dispatch, e))), magic("watch", ((e, { evaluateLater: t, cleanup: n }) => (e, r) => { let i = t(e), o = watch((() => { let e; return i((t => e = t)), e }), r); n(o) })), magic("store", getStores), magic("data", (e => scope(e))), magic("root", (e => closestRoot(e))), magic("refs", (e => (e._x_refs_proxy || (e._x_refs_proxy = mergeProxies(getArrayOfRefObject(e))), e._x_refs_proxy))); var globalIdMemo = {}; function findAndIncrementId(e) { return globalIdMemo[e] || (globalIdMemo[e] = 0), ++globalIdMemo[e] } function closestIdRoot(e, t) { return findClosest(e, (e => { if (e._x_ids && e._x_ids[t]) return !0 })) } function setIdRoot(e, t) { e._x_ids || (e._x_ids = {}), e._x_ids[t] || (e._x_ids[t] = findAndIncrementId(t)) } function cacheIdByNameOnElement(e, t, n, r) { if (e._x_id || (e._x_id = {}), e._x_id[t]) return e._x_id[t]; let i = r(); return e._x_id[t] = i, n((() => { delete e._x_id[t] })), i } function warnMissingPluginMagic(e, t, n) { magic(t, (r => warn(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, r))) } magic("id", ((e, { cleanup: t }) => (n, r = null) => cacheIdByNameOnElement(e, `${n}${r ? `-${r}` : ""}`, t, (() => { let t = closestIdRoot(e, n), i = t ? t._x_ids[n] : findAndIncrementId(n); return r ? `${n}-${i}-${r}` : `${n}-${i}` })))), interceptClone(((e, t) => { e._x_id && (t._x_id = e._x_id) })), magic("el", (e => e)), warnMissingPluginMagic("Focus", "focus", "focus"), warnMissingPluginMagic("Persist", "persist", "persist"), directive("modelable", ((e, { expression: t }, { effect: n, evaluateLater: r, cleanup: i }) => { let o = r(t), a = () => { let e; return o((t => e = t)), e }, s = r(`${t} = __placeholder`), l = e => s((() => { }), { scope: { __placeholder: e } }), c = a(); l(c), queueMicrotask((() => { if (!e._x_model) return; e._x_removeModelListeners.default(); let t = e._x_model.get, n = e._x_model.set, r = entangle({ get: () => t(), set(e) { n(e) } }, { get: () => a(), set(e) { l(e) } }); i(r) })) })), directive("teleport", ((e, { modifiers: t, expression: n }, { cleanup: r }) => { "template" !== e.tagName.toLowerCase() && warn("x-teleport can only be used on a <template> tag", e); let i = getTarget(n), o = e.content.cloneNode(!0).firstElementChild; e._x_teleport = o, o._x_teleportBack = e, e.setAttribute("data-teleport-template", !0), o.setAttribute("data-teleport-target", !0), e._x_forwardEvents && e._x_forwardEvents.forEach((t => { o.addEventListener(t, (t => { t.stopPropagation(), e.dispatchEvent(new t.constructor(t.type, t)) })) })), addScopeToNode(o, {}, e); let a = (e, t, n) => { n.includes("prepend") ? t.parentNode.insertBefore(e, t) : n.includes("append") ? t.parentNode.insertBefore(e, t.nextSibling) : t.appendChild(e) }; mutateDom((() => { a(o, i, t), initTree(o), o._x_ignore = !0 })), e._x_teleportPutBack = () => { let r = getTarget(n); mutateDom((() => { a(e._x_teleport, r, t) })) }, r((() => o.remove())) })); var teleportContainerDuringClone = document.createElement("div"); function getTarget(e) { let t = skipDuringClone((() => document.querySelector(e)), (() => teleportContainerDuringClone))(); return t || warn(`Cannot find x-teleport element for selector: "${e}"`), t } var handler = () => { }; function on(e, t, n, r) { let i = e, o = e => r(e), a = {}, s = (e, t) => n => t(e, n); if (n.includes("dot") && (t = dotSyntax(t)), n.includes("camel") && (t = camelCase2(t)), n.includes("passive") && (a.passive = !0), n.includes("capture") && (a.capture = !0), n.includes("window") && (i = window), n.includes("document") && (i = document), n.includes("debounce")) { let e = n[n.indexOf("debounce") + 1] || "invalid-wait", t = isNumeric(e.split("ms")[0]) ? Number(e.split("ms")[0]) : 250; o = debounce(o, t) } if (n.includes("throttle")) { let e = n[n.indexOf("throttle") + 1] || "invalid-wait", t = isNumeric(e.split("ms")[0]) ? Number(e.split("ms")[0]) : 250; o = throttle(o, t) } return n.includes("prevent") && (o = s(o, ((e, t) => { t.preventDefault(), e(t) }))), n.includes("stop") && (o = s(o, ((e, t) => { t.stopPropagation(), e(t) }))), n.includes("self") && (o = s(o, ((t, n) => { n.target === e && t(n) }))), (n.includes("away") || n.includes("outside")) && (i = document, o = s(o, ((t, n) => { e.contains(n.target) || !1 !== n.target.isConnected && (e.offsetWidth < 1 && e.offsetHeight < 1 || !1 !== e._x_isShown && t(n)) }))), n.includes("once") && (o = s(o, ((e, n) => { e(n), i.removeEventListener(t, o, a) }))), o = s(o, ((e, r) => { isKeyEvent(t) && isListeningForASpecificKeyThatHasntBeenPressed(r, n) || e(r) })), i.addEventListener(t, o, a), () => { i.removeEventListener(t, o, a) } } function dotSyntax(e) { return e.replace(/-/g, ".") } function camelCase2(e) { return e.toLowerCase().replace(/-(\w)/g, ((e, t) => t.toUpperCase())) } function isNumeric(e) { return !Array.isArray(e) && !isNaN(e) } function kebabCase2(e) { return [" ", "_"].includes(e) ? e : e.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase() } function isKeyEvent(e) { return ["keydown", "keyup"].includes(e) } function isListeningForASpecificKeyThatHasntBeenPressed(e, t) { let n = t.filter((e => !["window", "document", "prevent", "stop", "once", "capture"].includes(e))); if (n.includes("debounce")) { let e = n.indexOf("debounce"); n.splice(e, isNumeric((n[e + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (n.includes("throttle")) { let e = n.indexOf("throttle"); n.splice(e, isNumeric((n[e + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (0 === n.length) return !1; if (1 === n.length && keyToModifiers(e.key).includes(n[0])) return !1; const r = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter((e => n.includes(e))); if (n = n.filter((e => !r.includes(e))), r.length > 0) { if (r.filter((t => ("cmd" !== t && "super" !== t || (t = "meta"), e[`${t}Key`]))).length === r.length && keyToModifiers(e.key).includes(n[0])) return !1 } return !0 } function keyToModifiers(e) { if (!e) return []; e = kebabCase2(e); let t = { ctrl: "control", slash: "/", space: " ", spacebar: " ", cmd: "meta", esc: "escape", up: "arrow-up", down: "arrow-down", left: "arrow-left", right: "arrow-right", period: ".", equal: "=", minus: "-", underscore: "_" }; return t[e] = e, Object.keys(t).map((n => { if (t[n] === e) return n })).filter((e => e)) } function getInputValue(e, t, n, r) { return mutateDom((() => { if (n instanceof CustomEvent && void 0 !== n.detail) return null !== n.detail && void 0 !== n.detail ? n.detail : n.target.value; if ("checkbox" === e.type) { if (Array.isArray(r)) { let e = null; return e = t.includes("number") ? safeParseNumber(n.target.value) : t.includes("boolean") ? safeParseBoolean(n.target.value) : n.target.value, n.target.checked ? r.concat([e]) : r.filter((t => !checkedAttrLooseCompare2(t, e))) } return n.target.checked } return "select" === e.tagName.toLowerCase() && e.multiple ? t.includes("number") ? Array.from(n.target.selectedOptions).map((e => safeParseNumber(e.value || e.text))) : t.includes("boolean") ? Array.from(n.target.selectedOptions).map((e => safeParseBoolean(e.value || e.text))) : Array.from(n.target.selectedOptions).map((e => e.value || e.text)) : t.includes("number") ? safeParseNumber(n.target.value) : t.includes("boolean") ? safeParseBoolean(n.target.value) : t.includes("trim") ? n.target.value.trim() : n.target.value })) } function safeParseNumber(e) { let t = e ? parseFloat(e) : null; return isNumeric2(t) ? t : e } function checkedAttrLooseCompare2(e, t) { return e == t } function isNumeric2(e) { return !Array.isArray(e) && !isNaN(e) } function isGetterSetter(e) { return null !== e && "object" == typeof e && "function" == typeof e.get && "function" == typeof e.set } handler.inline = (e, { modifiers: t }, { cleanup: n }) => { t.includes("self") ? e._x_ignoreSelf = !0 : e._x_ignore = !0, n((() => { t.includes("self") ? delete e._x_ignoreSelf : delete e._x_ignore })) }, directive("ignore", handler), directive("effect", skipDuringClone(((e, { expression: t }, { effect: n }) => { n(evaluateLater(e, t)) }))), directive("model", ((e, { modifiers: t, expression: n }, { effect: r, cleanup: i }) => { let o = e; t.includes("parent") && (o = e.parentNode); let a, s = evaluateLater(o, n); a = "string" == typeof n ? evaluateLater(o, `${n} = __placeholder`) : "function" == typeof n && "string" == typeof n() ? evaluateLater(o, `${n()} = __placeholder`) : () => { }; let l = () => { let e; return s((t => e = t)), isGetterSetter(e) ? e.get() : e }, c = e => { let t; s((e => t = e)), isGetterSetter(t) ? t.set(e) : a((() => { }), { scope: { __placeholder: e } }) }; "string" == typeof n && "radio" === e.type && mutateDom((() => { e.hasAttribute("name") || e.setAttribute("name", n) })); var u = "select" === e.tagName.toLowerCase() || ["checkbox", "radio"].includes(e.type) || t.includes("lazy") ? "change" : "input"; let d = isCloning ? () => { } : on(e, u, t, (n => { c(getInputValue(e, t, n, l())) })); if (t.includes("fill") && ([void 0, null, ""].includes(l()) || "checkbox" === e.type && Array.isArray(l())) && e.dispatchEvent(new Event(u, {})), e._x_removeModelListeners || (e._x_removeModelListeners = {}), e._x_removeModelListeners.default = d, i((() => e._x_removeModelListeners.default())), e.form) { let t = on(e.form, "reset", [], (t => { nextTick((() => e._x_model && e._x_model.set(e.value))) })); i((() => t())) } e._x_model = { get: () => l(), set(e) { c(e) } }, e._x_forceModelUpdate = t => { void 0 === t && "string" == typeof n && n.match(/\./) && (t = ""), window.fromModel = !0, mutateDom((() => bind(e, "value", t))), delete window.fromModel }, r((() => { let n = l(); t.includes("unintrusive") && document.activeElement.isSameNode(e) || e._x_forceModelUpdate(n) })) })), directive("cloak", (e => queueMicrotask((() => mutateDom((() => e.removeAttribute(prefix("cloak")))))))), addInitSelector((() => `[${prefix("init")}]`)), directive("init", skipDuringClone(((e, { expression: t }, { evaluate: n }) => "string" == typeof t ? !!t.trim() && n(t, {}, !1) : n(t, {}, !1)))), directive("text", ((e, { expression: t }, { effect: n, evaluateLater: r }) => { let i = r(t); n((() => { i((t => { mutateDom((() => { e.textContent = t })) })) })) })), directive("html", ((e, { expression: t }, { effect: n, evaluateLater: r }) => { let i = r(t); n((() => { i((t => { mutateDom((() => { e.innerHTML = t, e._x_ignoreSelf = !0, initTree(e), delete e._x_ignoreSelf })) })) })) })), mapAttributes(startingWith(":", into(prefix("bind:")))); var handler2 = (e, { value: t, modifiers: n, expression: r, original: i }, { effect: o }) => { if (!t) { let t = {}; return injectBindingProviders(t), void evaluateLater(e, r)((t => { applyBindingsObject(e, t, i) }), { scope: t }) } if ("key" === t) return storeKeyForXFor(e, r); if (e._x_inlineBindings && e._x_inlineBindings[t] && e._x_inlineBindings[t].extract) return; let a = evaluateLater(e, r); o((() => a((i => { void 0 === i && "string" == typeof r && r.match(/\./) && (i = ""), mutateDom((() => bind(e, t, i, n))) })))) }; function storeKeyForXFor(e, t) { e._x_keyExpression = t } function shouldSkipRegisteringDataDuringClone(e) { return !!isCloning && (!!isCloningLegacy || e.hasAttribute("data-has-alpine-state")) } function loop(e, t, n, r) { let i = e; n((n => { isNumeric3(n) && n >= 0 && (n = Array.from(Array(n).keys(), (e => e + 1))), void 0 === n && (n = []); let o = e._x_lookup, a = e._x_prevKeys, s = [], l = []; if ("object" != typeof (c = n) || Array.isArray(c)) for (let e = 0; e < n.length; e++) { let i = getIterationScopeVariables(t, n[e], e, n); r((e => l.push(e)), { scope: { index: e, ...i } }), s.push(i) } else n = Object.entries(n).map((([e, i]) => { let o = getIterationScopeVariables(t, i, e, n); r((e => l.push(e)), { scope: { index: e, ...o } }), s.push(o) })); var c; let u = [], d = [], f = [], p = []; for (let e = 0; e < a.length; e++) { let t = a[e]; -1 === l.indexOf(t) && f.push(t) } a = a.filter((e => !f.includes(e))); let _ = "template"; for (let e = 0; e < l.length; e++) { let t = l[e], n = a.indexOf(t); if (-1 === n) a.splice(e, 0, t), u.push([_, e]); else if (n !== e) { let t = a.splice(e, 1)[0], r = a.splice(n - 1, 1)[0]; a.splice(e, 0, r), a.splice(n, 0, t), d.push([t, r]) } else p.push(t); _ = t } for (let e = 0; e < f.length; e++) { let t = f[e]; o[t]._x_effects && o[t]._x_effects.forEach(dequeueJob), o[t].remove(), o[t] = null, delete o[t] } for (let e = 0; e < d.length; e++) { let [t, n] = d[e], r = o[t], a = o[n], c = document.createElement("div"); mutateDom((() => { a || warn('x-for ":key" is undefined or invalid', i), a.after(c), r.after(a), a._x_currentIfEl && a.after(a._x_currentIfEl), c.before(r), r._x_currentIfEl && r.after(r._x_currentIfEl), c.remove() })), a._x_refreshXForScope(s[l.indexOf(n)]) } for (let e = 0; e < u.length; e++) { let [t, n] = u[e], r = "template" === t ? i : o[t]; r._x_currentIfEl && (r = r._x_currentIfEl); let a = s[n], c = l[n], d = document.importNode(i.content, !0).firstElementChild, f = reactive(a); addScopeToNode(d, f, i), d._x_refreshXForScope = e => { Object.entries(e).forEach((([e, t]) => { f[e] = t })) }, mutateDom((() => { r.after(d), initTree(d) })), "object" == typeof c && warn("x-for key cannot be an object, it must be a string or an integer", i), o[c] = d } for (let e = 0; e < p.length; e++)o[p[e]]._x_refreshXForScope(s[l.indexOf(p[e])]); i._x_prevKeys = l })) } function parseForExpression(e) { let t = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, n = e.match(/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/); if (!n) return; let r = {}; r.items = n[2].trim(); let i = n[1].replace(/^\s*\(|\)\s*$/g, "").trim(), o = i.match(t); return o ? (r.item = i.replace(t, "").trim(), r.index = o[1].trim(), o[2] && (r.collection = o[2].trim())) : r.item = i, r } function getIterationScopeVariables(e, t, n, r) { let i = {}; if (/^\[.*\]$/.test(e.item) && Array.isArray(t)) { e.item.replace("[", "").replace("]", "").split(",").map((e => e.trim())).forEach(((e, n) => { i[e] = t[n] })) } else if (/^\{.*\}$/.test(e.item) && !Array.isArray(t) && "object" == typeof t) { e.item.replace("{", "").replace("}", "").split(",").map((e => e.trim())).forEach((e => { i[e] = t[e] })) } else i[e.item] = t; return e.index && (i[e.index] = n), e.collection && (i[e.collection] = r), i } function isNumeric3(e) { return !Array.isArray(e) && !isNaN(e) } function handler3() { } function warnMissingPluginDirective(e, t, n) { directive(t, (r => warn(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, r))) } handler2.inline = (e, { value: t, modifiers: n, expression: r }) => { t && (e._x_inlineBindings || (e._x_inlineBindings = {}), e._x_inlineBindings[t] = { expression: r, extract: !1 }) }, directive("bind", handler2), addRootSelector((() => `[${prefix("data")}]`)), directive("data", ((e, { expression: t }, { cleanup: n }) => { if (shouldSkipRegisteringDataDuringClone(e)) return; t = "" === t ? "{}" : t; let r = {}; injectMagics(r, e); let i = {}; injectDataProviders(i, r); let o = evaluate(e, t, { scope: i }); void 0 !== o && !0 !== o || (o = {}), injectMagics(o, e); let a = reactive(o); initInterceptors2(a); let s = addScopeToNode(e, a); a.init && evaluate(e, a.init), n((() => { a.destroy && evaluate(e, a.destroy), s() })) })), interceptClone(((e, t) => { e._x_dataStack && (t._x_dataStack = e._x_dataStack, t.setAttribute("data-has-alpine-state", !0)) })), directive("show", ((e, { modifiers: t, expression: n }, { effect: r }) => { let i = evaluateLater(e, n); e._x_doHide || (e._x_doHide = () => { mutateDom((() => { e.style.setProperty("display", "none", t.includes("important") ? "important" : void 0) })) }), e._x_doShow || (e._x_doShow = () => { mutateDom((() => { 1 === e.style.length && "none" === e.style.display ? e.removeAttribute("style") : e.style.removeProperty("display") })) }); let o, a = () => { e._x_doHide(), e._x_isShown = !1 }, s = () => { e._x_doShow(), e._x_isShown = !0 }, l = () => setTimeout(s), c = once((e => e ? s() : a()), (t => { "function" == typeof e._x_toggleAndCascadeWithTransitions ? e._x_toggleAndCascadeWithTransitions(e, t, s, a) : t ? l() : a() })), u = !0; r((() => i((e => { (u || e !== o) && (t.includes("immediate") && (e ? l() : a()), c(e), o = e, u = !1) })))) })), directive("for", ((e, { expression: t }, { effect: n, cleanup: r }) => { let i = parseForExpression(t), o = evaluateLater(e, i.items), a = evaluateLater(e, e._x_keyExpression || "index"); e._x_prevKeys = [], e._x_lookup = {}, n((() => loop(e, i, o, a))), r((() => { Object.values(e._x_lookup).forEach((e => e.remove())), delete e._x_prevKeys, delete e._x_lookup })) })), handler3.inline = (e, { expression: t }, { cleanup: n }) => { let r = closestRoot(e); r._x_refs || (r._x_refs = {}), r._x_refs[t] = e, n((() => delete r._x_refs[t])) }, directive("ref", handler3), directive("if", ((e, { expression: t }, { effect: n, cleanup: r }) => { "template" !== e.tagName.toLowerCase() && warn("x-if can only be used on a <template> tag", e); let i = evaluateLater(e, t); n((() => i((t => { t ? (() => { if (e._x_currentIfEl) return e._x_currentIfEl; let t = e.content.cloneNode(!0).firstElementChild; addScopeToNode(t, {}, e), mutateDom((() => { e.after(t), initTree(t) })), e._x_currentIfEl = t, e._x_undoIf = () => { walk(t, (e => { e._x_effects && e._x_effects.forEach(dequeueJob) })), t.remove(), delete e._x_currentIfEl } })() : e._x_undoIf && (e._x_undoIf(), delete e._x_undoIf) })))), r((() => e._x_undoIf && e._x_undoIf())) })), directive("id", ((e, { expression: t }, { evaluate: n }) => { n(t).forEach((t => setIdRoot(e, t))) })), interceptClone(((e, t) => { e._x_ids && (t._x_ids = e._x_ids) })), mapAttributes(startingWith("@", into(prefix("on:")))), directive("on", skipDuringClone(((e, { value: t, modifiers: n, expression: r }, { cleanup: i }) => { let o = r ? evaluateLater(e, r) : () => { }; "template" === e.tagName.toLowerCase() && (e._x_forwardEvents || (e._x_forwardEvents = []), e._x_forwardEvents.includes(t) || e._x_forwardEvents.push(t)); let a = on(e, t, n, (e => { o((() => { }), { scope: { $event: e }, params: [e] }) })); i((() => a())) }))), warnMissingPluginDirective("Collapse", "collapse", "collapse"), warnMissingPluginDirective("Intersect", "intersect", "intersect"), warnMissingPluginDirective("Focus", "trap", "focus"), warnMissingPluginDirective("Mask", "mask", "mask"), alpine_default.setEvaluator(normalEvaluator), alpine_default.setReactivityEngine({ reactive: import_reactivity10.reactive, effect: import_reactivity10.effect, release: import_reactivity10.stop, raw: import_reactivity10.toRaw }); var src_default = alpine_default, module_default = alpine_default;
//# sourceMappingURL=/sm/3f550ad4c43e5bb2d80ae612972e54a7a4fa39885ae1d958223937d1ef234325.map
